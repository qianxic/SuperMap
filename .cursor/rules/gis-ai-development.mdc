# GIS + AI æ™ºèƒ½åˆ†æç³»ç»Ÿå¼€å‘è§„èŒƒ

## ğŸ—ï¸ å¾®æœåŠ¡æ¶æ„è®¾è®¡

### æœåŠ¡åˆ†ç¦»ç­–ç•¥
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Frontend      â”‚    â”‚   API Gateway   â”‚    â”‚   Load Balancer â”‚
â”‚   (Vue.js)      â”‚â—„â”€â”€â–ºâ”‚   (FastAPI)     â”‚â—„â”€â”€â–ºâ”‚   (Nginx)       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                â”‚
                â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                â”‚               â”‚               â”‚
        â”Œâ”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”
        â”‚   AI Service â”‚ â”‚ GIS Service â”‚ â”‚ User Auth â”‚
        â”‚   (Python)   â”‚ â”‚(JavaScript) â”‚ â”‚ (Python)  â”‚
        â”‚  LangChain   â”‚ â”‚  Node.js    â”‚ â”‚  FastAPI  â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## ğŸ”§ æŠ€æœ¯æ ˆè§„èŒƒ

### AIæœåŠ¡ (Python + LangChain)
- **è¯­è¨€**: Python 3.11+
- **AIæ¡†æ¶**: LangChain + OpenAI
- **Webæ¡†æ¶**: FastAPI + Uvicorn
- **æ•°æ®åº“**: PostgreSQL + PostGIS (ç©ºé—´æ•°æ®)
- **ç¼“å­˜**: Redis Cluster
- **å‘é‡æ•°æ®åº“**: Qdrant/Weaviate
- **ç›‘æ§**: Prometheus + Grafana

### GISåˆ†ææœåŠ¡ (JavaScript + Node.js)
- **è¯­è¨€**: JavaScript/TypeScript
- **è¿è¡Œæ—¶**: Node.js 18+
- **Webæ¡†æ¶**: Express.js + Koa.js
- **GISåº“**: Turf.js, JSTS
- **æ•°æ®åº“**: PostgreSQL + PostGIS
- **ç¼“å­˜**: Redis
- **ä»»åŠ¡é˜Ÿåˆ—**: Bull/BullMQ
- **ç›‘æ§**: PM2 + New Relic

### å‰ç«¯æœåŠ¡ (Vue.js)
- **æ¡†æ¶**: Vue.js 3 + TypeScript
- **åœ°å›¾**: SuperMap iClient
- **çŠ¶æ€ç®¡ç†**: Pinia
- **UIç»„ä»¶**: è‡ªå®šä¹‰ç»„ä»¶åº“
- **æ„å»ºå·¥å…·**: Vite

## ğŸ AIæœåŠ¡å¼€å‘è§„èŒƒ (Python)

### é¡¹ç›®ç»“æ„
```
ai-service/
â”œâ”€â”€ app/
â”‚   â”œâ”€â”€ domains/           # é¢†åŸŸå±‚
â”‚   â”‚   â”œâ”€â”€ agent/        # æ™ºèƒ½ä½“åŸŸ
â”‚   â”‚   â”œâ”€â”€ knowledge/    # çŸ¥è¯†åº“åŸŸ
â”‚   â”‚   â””â”€â”€ workflow/     # å·¥ä½œæµåŸŸ
â”‚   â”œâ”€â”€ application/      # åº”ç”¨å±‚
â”‚   â”œâ”€â”€ infrastructure/   # åŸºç¡€è®¾æ–½å±‚
â”‚   â”‚   â”œâ”€â”€ ai/          # AIåŸºç¡€è®¾æ–½
â”‚   â”‚   â”œâ”€â”€ database/    # æ•°æ®è®¿é—®
â”‚   â”‚   â””â”€â”€ external/    # å¤–éƒ¨æœåŠ¡
â”‚   â””â”€â”€ api/             # APIå±‚
â”œâ”€â”€ requirements.txt
â”œâ”€â”€ Dockerfile
â””â”€â”€ docker-compose.yml
```

### LangChainé›†æˆè§„èŒƒ
```python
# infrastructure/ai/agent_hub.py
from langchain.agents import AgentExecutor, create_openai_functions_agent
from langchain.tools import BaseTool
from langchain.schema import BaseMessage
from typing import List, Dict, Any

class AgentHub:
    """æ™ºèƒ½ä½“åè°ƒä¸­å¿ƒ"""
    
    def __init__(self):
        self.coordinator = CoordinatorAgent()
        self.executor = ExecutorAgent()
        self.aggregator = AggregatorAgent()
        self.tools = self._load_tools()
    
    def _load_tools(self) -> List[BaseTool]:
        """åŠ è½½å·¥å…·é›†"""
        return [
            GISAnalysisTool(),
            KnowledgeSearchTool(),
            DataQueryTool()
        ]
    
    async def process_query(self, query: str, context: Dict[str, Any]) -> Dict[str, Any]:
        """å¤„ç†ç”¨æˆ·æŸ¥è¯¢"""
        # 1. åè°ƒæ™ºèƒ½ä½“è§£ææ„å›¾
        intent = await self.coordinator.analyze_intent(query, context)
        
        # 2. æ‰§è¡Œæ™ºèƒ½ä½“å¹¶è¡Œå¤„ç†
        results = await self.executor.execute_tasks(intent.tasks, self.tools)
        
        # 3. èšåˆæ™ºèƒ½ä½“æ•´åˆç»“æœ
        final_result = await self.aggregator.combine_results(results)
        
        return final_result

class CoordinatorAgent:
    """åè°ƒæ™ºèƒ½ä½“"""
    
    async def analyze_intent(self, query: str, context: Dict[str, Any]) -> Dict[str, Any]:
        """åˆ†æç”¨æˆ·æ„å›¾"""
        prompt = f"""
        ä½ æ˜¯ä¸€ä¸ªGISåˆ†æåè°ƒæ™ºèƒ½ä½“ï¼Œè´Ÿè´£è§£æç”¨æˆ·çš„åœ°ç†åˆ†æéœ€æ±‚ã€‚
        
        ç”¨æˆ·æŸ¥è¯¢: {query}
        ä¸Šä¸‹æ–‡: {context}
        
        è¯·åˆ†æç”¨æˆ·æ„å›¾å¹¶ç”Ÿæˆæ‰§è¡Œè®¡åˆ’:
        1. è¯†åˆ«åˆ†æç±»å‹ (ç¼“å†²åŒºã€è·ç¦»ã€å¯è¾¾æ€§ç­‰)
        2. æå–å…³é”®å‚æ•° (åŠå¾„ã€ç›®æ ‡å¯¹è±¡ç­‰)
        3. ç”Ÿæˆæ‰§è¡Œä»»åŠ¡åˆ—è¡¨
        
        è¿”å›JSONæ ¼å¼çš„æ‰§è¡Œè®¡åˆ’ã€‚
        """
        
        # è°ƒç”¨OpenAI API
        response = await self.llm_client.chat_completion(prompt)
        return self._parse_intent(response.content)

class ExecutorAgent:
    """æ‰§è¡Œæ™ºèƒ½ä½“"""
    
    async def execute_tasks(self, tasks: List[Dict], tools: List[BaseTool]) -> List[Dict]:
        """æ‰§è¡Œä»»åŠ¡åˆ—è¡¨"""
        results = []
        
        for task in tasks:
            # é€‰æ‹©åˆé€‚çš„å·¥å…·
            tool = self._select_tool(task, tools)
            
            # æ‰§è¡Œä»»åŠ¡
            result = await tool.execute(task)
            results.append(result)
        
        return results

class AggregatorAgent:
    """èšåˆæ™ºèƒ½ä½“"""
    
    async def combine_results(self, results: List[Dict]) -> Dict[str, Any]:
        """æ•´åˆç»“æœ"""
        # åˆ†æç»“æœèšåˆé€»è¾‘
        combined_result = {
            "success": True,
            "data": results,
            "summary": self._generate_summary(results),
            "visualization": self._generate_visualization(results)
        }
        
        return combined_result
```

### å·¥å…·é›†æˆ
```python
# infrastructure/ai/tools/gis_tools.py
from langchain.tools import BaseTool
from typing import Dict, Any
import httpx

class GISAnalysisTool(BaseTool):
    """GISåˆ†æå·¥å…·"""
    
    name = "gis_analysis"
    description = "æ‰§è¡ŒGISç©ºé—´åˆ†æï¼ŒåŒ…æ‹¬ç¼“å†²åŒºã€è·ç¦»ã€å¯è¾¾æ€§åˆ†æ"
    
    async def _run(self, task: Dict[str, Any]) -> Dict[str, Any]:
        """æ‰§è¡ŒGISåˆ†æ"""
        # è°ƒç”¨GISæœåŠ¡API
        async with httpx.AsyncClient() as client:
            response = await client.post(
                "http://gis-service:3000/api/v1/analysis",
                json=task,
                timeout=30.0
            )
            
            if response.status_code == 200:
                return response.json()
            else:
                raise Exception(f"GISåˆ†æå¤±è´¥: {response.text}")
    
    async def _arun(self, task: Dict[str, Any]) -> Dict[str, Any]:
        """å¼‚æ­¥æ‰§è¡Œ"""
        return await self._run(task)

class KnowledgeSearchTool(BaseTool):
    """çŸ¥è¯†åº“æœç´¢å·¥å…·"""
    
    name = "knowledge_search"
    description = "æœç´¢GISç›¸å…³çŸ¥è¯†åº“"
    
    async def _run(self, query: str) -> Dict[str, Any]:
        """æœç´¢çŸ¥è¯†åº“"""
        # å‘é‡æ•°æ®åº“æœç´¢
        results = await self.vector_db.search(query, top_k=5)
        return {"results": results}
```

## ğŸŸ¨ GISåˆ†ææœåŠ¡å¼€å‘è§„èŒƒ (JavaScript)

### é¡¹ç›®ç»“æ„
```
gis-service/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ domains/          # é¢†åŸŸå±‚
â”‚   â”‚   â”œâ”€â”€ spatial/     # ç©ºé—´åˆ†æåŸŸ
â”‚   â”‚   â”œâ”€â”€ geometry/    # å‡ ä½•å¤„ç†åŸŸ
â”‚   â”‚   â””â”€â”€ data/        # æ•°æ®ç®¡ç†åŸŸ
â”‚   â”œâ”€â”€ application/     # åº”ç”¨å±‚
â”‚   â”œâ”€â”€ infrastructure/  # åŸºç¡€è®¾æ–½å±‚
â”‚   â”‚   â”œâ”€â”€ database/   # æ•°æ®è®¿é—®
â”‚   â”‚   â”œâ”€â”€ cache/      # ç¼“å­˜æœåŠ¡
â”‚   â”‚   â””â”€â”€ external/   # å¤–éƒ¨æœåŠ¡
â”‚   â”œâ”€â”€ api/            # APIå±‚
â”‚   â””â”€â”€ utils/          # å·¥å…·å‡½æ•°
â”œâ”€â”€ package.json
â”œâ”€â”€ Dockerfile
â””â”€â”€ docker-compose.yml
```

### Express.jsåº”ç”¨ç»“æ„
```javascript
// src/app.js
const express = require('express');
const cors = require('cors');
const helmet = require('helmet');
const rateLimit = require('express-rate-limit');
const compression = require('compression');

const spatialAnalysisRoutes = require('./api/routes/spatial-analysis');
const geometryRoutes = require('./api/routes/geometry');
const dataRoutes = require('./api/routes/data');

const app = express();

// ä¸­é—´ä»¶é…ç½®
app.use(helmet());
app.use(compression());
app.use(cors({
  origin: process.env.ALLOWED_ORIGINS?.split(',') || '*',
  credentials: true
}));

// é™æµé…ç½®
const limiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15åˆ†é’Ÿ
  max: 100 // é™åˆ¶æ¯ä¸ªIP 15åˆ†é’Ÿå†…æœ€å¤š100ä¸ªè¯·æ±‚
});
app.use('/api/', limiter);

// è·¯ç”±é…ç½®
app.use('/api/v1/spatial-analysis', spatialAnalysisRoutes);
app.use('/api/v1/geometry', geometryRoutes);
app.use('/api/v1/data', dataRoutes);

// é”™è¯¯å¤„ç†ä¸­é—´ä»¶
app.use((err, req, res, next) => {
  console.error(err.stack);
  res.status(500).json({
    success: false,
    message: 'å†…éƒ¨æœåŠ¡å™¨é”™è¯¯',
    error: process.env.NODE_ENV === 'development' ? err.message : undefined
  });
});

module.exports = app;
```

### ç©ºé—´åˆ†ææœåŠ¡
```javascript
// src/domains/spatial/spatial-analysis.service.js
const turf = require('@turf/turf');
const { Pool } = require('pg');
const redis = require('redis');

class SpatialAnalysisService {
  constructor() {
    this.db = new Pool({
      connectionString: process.env.DATABASE_URL
    });
    this.redis = redis.createClient({
      url: process.env.REDIS_URL
    });
  }

  async bufferAnalysis(geometry, radius, options = {}) {
    """ç¼“å†²åŒºåˆ†æ"""
    try {
      // å‚æ•°éªŒè¯
      if (!geometry || !radius || radius <= 0) {
        throw new Error('æ— æ•ˆçš„å‡ ä½•å¯¹è±¡æˆ–åŠå¾„');
      }

      // ç¼“å­˜é”®
      const cacheKey = `buffer:${JSON.stringify(geometry)}:${radius}`;
      
      // å°è¯•ä»ç¼“å­˜è·å–
      const cached = await this.redis.get(cacheKey);
      if (cached) {
        return JSON.parse(cached);
      }

      // æ‰§è¡Œç¼“å†²åŒºåˆ†æ
      const buffered = turf.buffer(geometry, radius, options);
      
      // è®¡ç®—é¢ç§¯
      const area = turf.area(buffered);
      
      const result = {
        geometry: buffered,
        area: area,
        radius: radius,
        unit: options.units || 'kilometers'
      };

      // ç¼“å­˜ç»“æœ
      await this.redis.setex(cacheKey, 3600, JSON.stringify(result));
      
      return result;
    } catch (error) {
      throw new Error(`ç¼“å†²åŒºåˆ†æå¤±è´¥: ${error.message}`);
    }
  }

  async distanceAnalysis(point1, point2, options = {}) {
    """è·ç¦»åˆ†æ"""
    try {
      const distance = turf.distance(point1, point2, options);
      
      return {
        distance: distance,
        unit: options.units || 'kilometers',
        point1: point1,
        point2: point2
      };
    } catch (error) {
      throw new Error(`è·ç¦»åˆ†æå¤±è´¥: ${error.message}`);
    }
  }

  async spatialQuery(geometry, relation, targetLayer, options = {}) {
    """ç©ºé—´æŸ¥è¯¢"""
    try {
      // æ„å»ºSQLæŸ¥è¯¢
      const query = `
        SELECT id, name, geometry, properties
        FROM ${targetLayer}
        WHERE ST_${relation.toUpperCase()}(geometry, ST_GeomFromGeoJSON($1))
        ${options.limit ? `LIMIT ${options.limit}` : ''}
      `;

      const result = await this.db.query(query, [JSON.stringify(geometry)]);
      
      return {
        count: result.rowCount,
        features: result.rows.map(row => ({
          id: row.id,
          name: row.name,
          geometry: row.geometry,
          properties: row.properties
        }))
      };
    } catch (error) {
      throw new Error(`ç©ºé—´æŸ¥è¯¢å¤±è´¥: ${error.message}`);
    }
  }
}

module.exports = SpatialAnalysisService;
```

### APIè·¯ç”±
```javascript
// src/api/routes/spatial-analysis.js
const express = require('express');
const router = express.Router();
const SpatialAnalysisService = require('../../domains/spatial/spatial-analysis.service');
const { validateGeometry, validateRadius } = require('../../utils/validators');

const spatialService = new SpatialAnalysisService();

// ç¼“å†²åŒºåˆ†æ
router.post('/buffer', async (req, res) => {
  try {
    const { geometry, radius, options } = req.body;
    
    // å‚æ•°éªŒè¯
    if (!validateGeometry(geometry)) {
      return res.status(400).json({
        success: false,
        message: 'æ— æ•ˆçš„å‡ ä½•å¯¹è±¡'
      });
    }
    
    if (!validateRadius(radius)) {
      return res.status(400).json({
        success: false,
        message: 'æ— æ•ˆçš„åŠå¾„å€¼'
      });
    }
    
    // æ‰§è¡Œåˆ†æ
    const result = await spatialService.bufferAnalysis(geometry, radius, options);
    
    res.json({
      success: true,
      message: 'ç¼“å†²åŒºåˆ†æå®Œæˆ',
      data: result
    });
  } catch (error) {
    console.error('ç¼“å†²åŒºåˆ†æé”™è¯¯:', error);
    res.status(500).json({
      success: false,
      message: error.message
    });
  }
});

// è·ç¦»åˆ†æ
router.post('/distance', async (req, res) => {
  try {
    const { point1, point2, options } = req.body;
    
    const result = await spatialService.distanceAnalysis(point1, point2, options);
    
    res.json({
      success: true,
      message: 'è·ç¦»åˆ†æå®Œæˆ',
      data: result
    });
  } catch (error) {
    console.error('è·ç¦»åˆ†æé”™è¯¯:', error);
    res.status(500).json({
      success: false,
      message: error.message
    });
  }
});

// ç©ºé—´æŸ¥è¯¢
router.post('/query', async (req, res) => {
  try {
    const { geometry, relation, targetLayer, options } = req.body;
    
    const result = await spatialService.spatialQuery(
      geometry, relation, targetLayer, options
    );
    
    res.json({
      success: true,
      message: 'ç©ºé—´æŸ¥è¯¢å®Œæˆ',
      data: result
    });
  } catch (error) {
    console.error('ç©ºé—´æŸ¥è¯¢é”™è¯¯:', error);
    res.status(500).json({
      success: false,
      message: error.message
    });
  }
});

module.exports = router;
```

## ğŸ”„ æœåŠ¡é—´é€šä¿¡

### APIç½‘å…³é…ç½®
```python
# api-gateway/main.py
from fastapi import FastAPI, HTTPException
from fastapi.middleware.cors import CORSMiddleware
import httpx
from typing import Dict, Any

app = FastAPI(title="SuperMap API Gateway")

# CORSé…ç½®
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# æœåŠ¡å‘ç°
SERVICES = {
    "ai": "http://ai-service:8001",
    "gis": "http://gis-service:8090",
    "auth": "http://auth-service:8000"
}

@app.post("/api/v1/agent/chat")
async def chat_with_agent(request: Dict[str, Any]):
    """æ™ºèƒ½ä½“å¯¹è¯ - è½¬å‘åˆ°AIæœåŠ¡"""
    async with httpx.AsyncClient() as client:
        response = await client.post(
            f"{SERVICES['ai']}/api/v1/chat",
            json=request,
            timeout=30.0
        )
        return response.json()

@app.post("/api/v1/gis/buffer-analysis")
async def buffer_analysis(request: Dict[str, Any]):
    """ç¼“å†²åŒºåˆ†æ - è½¬å‘åˆ°GISæœåŠ¡"""
    async with httpx.AsyncClient() as client:
        response = await client.post(
            f"{SERVICES['gis']}/api/v1/spatial-analysis/buffer",
            json=request,
            timeout=30.0
        )
        return response.json()

@app.post("/api/v1/gis/distance-analysis")
async def distance_analysis(request: Dict[str, Any]):
    """è·ç¦»åˆ†æ - è½¬å‘åˆ°GISæœåŠ¡"""
    async with httpx.AsyncClient() as client:
        response = await client.post(
            f"{SERVICES['gis']}/api/v1/spatial-analysis/distance",
            json=request,
            timeout=30.0
        )
        return response.json()
```

## ğŸ“Š æ€§èƒ½ç›‘æ§æŒ‡æ ‡

### AIæœåŠ¡ç›‘æ§
- **APIå“åº”æ—¶é—´**: P95 < 3s (æ™ºèƒ½ä½“å¤„ç†è¾ƒæ…¢)
- **LangChainå¤„ç†æ—¶é—´**: P95 < 5s
- **å‘é‡æ£€ç´¢å»¶è¿Ÿ**: P99 < 100ms
- **å†…å­˜ä½¿ç”¨**: < 4GB

### GISæœåŠ¡ç›‘æ§
- **APIå“åº”æ—¶é—´**: P95 < 500ms
- **ç©ºé—´è®¡ç®—æ—¶é—´**: P95 < 1s
- **æ•°æ®åº“æŸ¥è¯¢æ—¶é—´**: P95 < 200ms
- **ç¼“å­˜å‘½ä¸­ç‡**: > 90%

### æ•´ä½“ç³»ç»Ÿç›‘æ§
- **æœåŠ¡å¯ç”¨æ€§**: > 99.9%
- **é”™è¯¯ç‡**: < 0.1%
- **å¹¶å‘å¤„ç†èƒ½åŠ›**: 1000+ QPS

## ğŸ³ Dockeréƒ¨ç½²é…ç½®

### AIæœåŠ¡Dockerfile
```dockerfile
# ai-service/Dockerfile
FROM python:3.11-slim

WORKDIR /app

# å®‰è£…ç³»ç»Ÿä¾èµ–
RUN apt-get update && apt-get install -y \
    gcc \
    g++ \
    && rm -rf /var/lib/apt/lists/*

# å¤åˆ¶ä¾èµ–æ–‡ä»¶
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# å¤åˆ¶åº”ç”¨ä»£ç 
COPY . .

# æš´éœ²ç«¯å£
EXPOSE 8000

# å¯åŠ¨å‘½ä»¤
CMD ["uvicorn", "app.main:app", "--host", "0.0.0.0", "--port", "8000"]
```

### GISæœåŠ¡Dockerfile
```dockerfile
# gis-service/Dockerfile
FROM node:18-alpine

WORKDIR /app

# å¤åˆ¶packageæ–‡ä»¶
COPY package*.json ./
RUN npm ci --only=production

# å¤åˆ¶åº”ç”¨ä»£ç 
COPY . .

# æš´éœ²ç«¯å£
EXPOSE 3000

# å¯åŠ¨å‘½ä»¤
CMD ["npm", "start"]
```

### Docker Composeé…ç½®
```yaml
# docker-compose.yml
version: '3.8'

services:
  # AIæœåŠ¡
  ai-service:
    build: ./ai-service
    ports:
      - "8000:8000"
    environment:
      - DATABASE_URL=postgresql://user:pass@postgres:5432/ai_db
      - REDIS_URL=redis://redis:6379
      - OPENAI_API_KEY=${OPENAI_API_KEY}
    depends_on:
      - postgres
      - redis
      - qdrant

  # GISæœåŠ¡
  gis-service:
    build: ./gis-service
    ports:
      - "3000:3000"
    environment:
      - DATABASE_URL=postgresql://user:pass@postgres:5432/gis_db
      - REDIS_URL=redis://redis:6379
    depends_on:
      - postgres
      - redis

  # APIç½‘å…³
  api-gateway:
    build: ./api-gateway
    ports:
      - "8080:8080"
    depends_on:
      - ai-service
      - gis-service

  # æ•°æ®åº“
  postgres:
    image: postgis/postgis:15-3.3
    environment:
      - POSTGRES_DB=supermap
      - POSTGRES_USER=user
      - POSTGRES_PASSWORD=pass
    volumes:
      - postgres_data:/var/lib/postgresql/data

  # Redisç¼“å­˜
  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"

  # å‘é‡æ•°æ®åº“
  qdrant:
    image: qdrant/qdrant:latest
    ports:
      - "6333:6333"
    volumes:
      - qdrant_data:/qdrant/storage

volumes:
  postgres_data:
  qdrant_data:
```

## ğŸ”§ å¼€å‘å·¥å…·é…ç½®

### AIæœåŠ¡å¼€å‘ç¯å¢ƒ
```bash
# ai-service/requirements.txt
fastapi==0.104.1
uvicorn==0.24.0
langchain==0.1.0
openai==1.3.0
psycopg2-binary==2.9.9
redis==5.0.1
qdrant-client==1.7.0
httpx==0.25.2
pydantic==2.5.0
python-jose==3.3.0
passlib==1.7.4
```

### GISæœåŠ¡å¼€å‘ç¯å¢ƒ
```json
// gis-service/package.json
{
  "name": "gis-analysis-service",
  "version": "1.0.0",
  "main": "src/app.js",
  "scripts": {
    "start": "node src/app.js",
    "dev": "nodemon src/app.js",
    "test": "jest"
  },
  "dependencies": {
    "express": "^4.18.2",
    "cors": "^2.8.5",
    "helmet": "^7.1.0",
    "express-rate-limit": "^7.1.5",
    "compression": "^1.7.4",
    "@turf/turf": "^6.5.0",
    "pg": "^8.11.3",
    "redis": "^4.6.10",
    "bull": "^4.12.0"
  },
  "devDependencies": {
    "nodemon": "^3.0.2",
    "jest": "^29.7.0"
  }
}
```

è¿™ç§åˆ†ç¦»æ¶æ„çš„ä¼˜åŠ¿ï¼š
1. **æŠ€æœ¯æ ˆä¼˜åŒ–**: æ¯ä¸ªæœåŠ¡ä½¿ç”¨æœ€é€‚åˆçš„æŠ€æœ¯æ ˆ
2. **ç‹¬ç«‹éƒ¨ç½²**: æœåŠ¡å¯ä»¥ç‹¬ç«‹æ‰©å±•å’Œéƒ¨ç½²
3. **æ•…éšœéš”ç¦»**: å•ä¸ªæœåŠ¡æ•…éšœä¸å½±å“æ•´ä½“ç³»ç»Ÿ
4. **å›¢é˜Ÿåä½œ**: ä¸åŒå›¢é˜Ÿå¯ä»¥ä¸“æ³¨äºä¸åŒæœåŠ¡
5. **æ€§èƒ½ä¼˜åŒ–**: é’ˆå¯¹ä¸åŒæœåŠ¡ç±»å‹è¿›è¡Œä¸“é—¨ä¼˜åŒ–
